# Copyright 2015 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Gradebook analytic - displays answers, scores per student."""

__author__ = 'Mike Gainer (mgainer@google.com)'

import csv
import re
import StringIO

from common import catch_and_log
from controllers import utils
from models import courses
from models import roles
from models import transforms
from modules.analytics import student_answers
from tools import verify
from tools.etl import etl_lib

_MODE_ARG_NAME = 'mode'
_MODE_SCORES = 'scores'
_MODE_QUESTIONS = 'questions'
_MODES = [_MODE_SCORES, _MODE_QUESTIONS]

# TODO(mgainer): Move RawAnswersDataSource, et. al. here from student_answers.py


class AbstractGradebookCsvGenerator(object):

    def __init__(self, app_context, source_context=None):
        self._app_context = app_context
        self._source_context = source_context

    def get_output(self):
        student_question_answers = self._fetch_all_question_answers()
        column_titles, ids_to_index = self._walk_course()
        answer_rows = self._reduce_answers(
            student_question_answers, ids_to_index)

        stream = StringIO.StringIO()
        csv_stream = csv.writer(stream, quoting=csv.QUOTE_MINIMAL)
        for row in [column_titles] + answer_rows:
            row = [i.encode('utf-8') if isinstance(i, unicode) else str(i)
                   for i in row]
            csv_stream.writerow(row)
        ret = stream.getvalue()
        stream.close()
        return ret

    def _fetch_all_question_answers(self):
        source_class = student_answers.RawAnswersDataSource
        values = []
        chunk_size = source_class.get_default_chunk_size()
        context_class = source_class.get_context_class()
        source_context = context_class.build_blank_default({}, chunk_size)
        catch_and_log_ = catch_and_log.CatchAndLog()
        sought_page_number = 0
        with catch_and_log_.propagate_exceptions('Loading gradebook data'):
            schema = source_class.get_schema(
                self._app_context, catch_and_log, source_context)
            while True:
                data, actual_page_number = source_class.fetch_values(
                    self._app_context, source_context, schema, catch_and_log_,
                    sought_page_number)
                if actual_page_number != sought_page_number:
                    break
                values.extend(data)
                if len(data) < source_context.chunk_size:
                    break
                sought_page_number += 1
        values.sort(key=lambda x: x['user_email'])
        return values

    def _walk_course(self):
        """Traverse course, producing helper items.

        Produces ordered items for scorable course elements; these are in
        syllabus order (taking into account pre/post Assessment).

        Returns:
          A 2-tuple, containing:
          - A list of titles for things in the course that can be scored;
            this includes top-level assessments, pre/post-assessments, and
            lessons.
          - A map keyed by 2-tuple of (unit_id, lesson_id), yielding the
            index corresponding to that 2-tuple in the titles list.
            NOTE: Tuples should index starting at 1, not 0.  The 0th
            column is reserved for the email address of the student.
        """
        raise NotImplementedError()

    def _reduce_answers(self, student_question_answers, ids_to_index):
        """Iterate over student answers to produce rows for CSV output.

        Args:
          student_question_answers: Rows, as generated by
              RawAnswersDataSource._postprocess_rows.  Each row corresponds to
              one answer to one question by one student.  All answers for each
              student are guaranteed to be adjacent.  This is not a complete
              Cartesian product of students X all possible questions; only the
              questions actually answered by the student will be present.  It
              is up to the subclass to correctly place results in the (fixed-
              width) CSV rows.
          ids_to_index: As described in return value for _walk_course().
        Returns:
          An iterable of iterables.  Each iterable should provide a list of
              items for a single student, starting with the student's
              email address.
        """
        raise NotImplementedError


class GradebookGradedItemsCsvGenerator(AbstractGradebookCsvGenerator):

    def _walk_course(self):
        course = courses.Course.get(app_context=self._app_context)

        titles = ['Email']
        indices_by_unit_and_lesson = {}

        def add_index(unit_id, lesson_id):
            """Convenience function; count by 1 each addition to indices map."""
            indices_by_unit_and_lesson[(str(unit_id), str(lesson_id))] = len(
                indices_by_unit_and_lesson)

        for unit in course.get_units():
            if unit.type == verify.UNIT_TYPE_ASSESSMENT:
                if not course.get_parent_unit(unit.unit_id):
                    titles.append(unit.title)
                    add_index(unit.unit_id, None)
            elif unit.type == verify.UNIT_TYPE_UNIT:
                if unit.pre_assessment:
                    assessment = course.find_unit_by_id(unit.pre_assessment)
                    titles.append('%s: %s' % (unit.title, assessment.title))
                    add_index(assessment.unit_id, None)
                for lesson in course.get_lessons(unit.unit_id):
                    titles.append('%s: %s' % (unit.title, lesson.title))
                    add_index(unit.unit_id, lesson.lesson_id)
                if unit.post_assessment:
                    assessment = course.find_unit_by_id(unit.post_assessment)
                    titles.append('%s: %s' % (unit.title, assessment.title))
                    add_index(assessment.unit_id, None)
        return titles, indices_by_unit_and_lesson

    def _reduce_answers(self, student_question_answers, ids_to_index):
        prev_email = None
        ret = []
        for answer in student_question_answers:
            if answer['user_email'] != prev_email:
                prev_email = answer['user_email']
                answers = [answer['user_email']] + [0.0] * len(ids_to_index)
                ret.append(answers)
            index = ids_to_index[(answer['unit_id'], answer['lesson_id'])] + 1
            answers[index] += answer['weighted_score']
        return ret


class GradebookAllQuestionsCsvGenerator(AbstractGradebookCsvGenerator):

    def produce_result_rows(self, student_question_answers):
        column_titles, ids_to_index = self._walk_course()
        answer_rows = self._reduce_answers(student_question_answers,
                                           ids_to_index)
        return [column_titles] + answer_rows


    def _walk_course(self):
        template_values = {}
        student_answers.OrderedQuestionsDataSource.fill_values(
            self._app_context, template_values)
        js_vars = transforms.loads(template_values['gradebook_js_vars'])
        course = courses.Course(None, app_context=self._app_context)
        questions, unused_page_number = (
            student_answers.CourseQuestionsDataSource.fetch_values(
                self._app_context, None, None, None, 0))
        question_names = {q['question_id']: q['description'] for q in questions}

        column_titles = ['Email']
        ids_to_index = {}
        question_keys = js_vars['question_keys']
        for question_key in question_keys:
            if '.' in question_key:
                unit_id, lesson_id, question_id = question_key.split('.')
                ids_to_index[(unit_id, lesson_id, question_id)] = 1 + 2 * len(
                    ids_to_index)
                question_name = question_names.get(question_id, 'UNKNOWN')
                column_titles.append(question_name + ' answer')
                column_titles.append(question_name + ' score')

        return column_titles, ids_to_index

    def _reduce_answers(self, student_question_answers, ids_to_index):
        prev_email = None
        ret = []
        for answer in student_question_answers:
            if answer['user_email'] != prev_email:
                prev_email = answer['user_email']
                answers = [answer['user_email']] + ['', 0.0] * len(ids_to_index)
                ret.append(answers)
            index = ids_to_index[
                (answer['unit_id'], answer['lesson_id'], answer['question_id'])]
            response = answer['answers']
            if len(response) == 1:
                answers[index] = response[0]
            else:
                answers[index] = str(response)
            answers[index + 1] = answer['weighted_score']
        return ret


def _generate_csv(app_context, mode):
    if mode == _MODE_SCORES:
        generator_class = GradebookGradedItemsCsvGenerator
    elif mode == _MODE_QUESTIONS:
        generator_class = GradebookAllQuestionsCsvGenerator
    else:
        raise ValueError('Mode "%s" not in %s' % (mode, ','.join(_MODES)))
    generator = generator_class(app_context)
    output = generator.get_output()
    return output


class DownloadAsCsv(etl_lib.CourseJob):
    """Use ETL framework to download gradebook data as .csv files.

    Usage:

    ./scripts/etl.sh run modules.analytics.gradebook.DownloadAsCsv \
        /the_course_name \
        appengine_instance_name \
        appengine_instance_name.appspot.com \
        --job_args='--mode=MODE --save_as=file_namne_to_save_as.csv'

    MODE can be "scores" or "questions".  "Scores" provides total scores for
    assessments and scored lessons for each student.  "Questions" gives
    the student's answer and score for each question.
    """

    def _configure_parser(self):
        self.parser.add_argument(
            '--%s' % _MODE_ARG_NAME, choices=_MODES)
        self.parser.add_argument(
            '--save_as', type=str, help='Path of the file to save output to')

    def main(self):
        app_context = self._get_app_context_or_die(
            self.etl_args.course_url_prefix)
        output = _generate_csv(app_context, self.args.mode)
        with open(self.args.save_as, 'w') as fp:
            fp.write(output)


class CsvDownloadHandler(utils.BaseHandler):

    URI = '/gradebook/csv'

    def get(self):
        if not roles.Roles.is_course_admin(self.app_context):
            self.error(401)
        mode = self.request.get(_MODE_ARG_NAME, _MODE_SCORES)
        output = _generate_csv(self.app_context, mode)
        filename = '%s_%s.csv' % (self.app_context.get_title(), mode)
        safe_filename = re.sub(r'[\"\']', '_', filename.lower())
        self.response.headers.add('Content-Type', 'text/csv')
        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1
        self.response.headers.add(
            'Content-Disposition',
            str('attachment; filename="%s"' % str(safe_filename)))
        self.response.write(output)
